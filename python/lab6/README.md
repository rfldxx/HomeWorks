### Рекурсивная реализация
Подробнее это разбиралось в [lab3](../lab3).
```py
def build_tree_recursive(h, r, f, g):
    return { r : [gen_bin_tree(h-1, F(r), f, g) for F in [f, g]] if h > 0 else [] }
```

### Дерево в виде массива
В нерекурсивном построении, будем хранить дерево как просто 0-индексированный массив `TreeList` на $2^{h+1} - 1$ элемент. \
Корень имеет значение равное `TreeList[0]`. \
Для вершины со значением по индексу $i$, левый потомок имеет значение в индексе $2 i +1$, правый - в индексе $2 i+2$.

Зная функция `f` и `g` (которые по значению в текущем узле возвращают  значение для левого / правого потомка) мы можем просто проитерировать по всем $i$:
```py
TreeList[0] = root_value
for i in range(1, N):
    TreeList[2*i+1] = f(TreeList[i])
    TreeList[2*i+2] = g(TreeList[i])
```

Итого мы получим какое-то из представлений дерева.

### Дерево в формате как и у build_tree_recursive
Если же мы хотим видимо реально стеком/очередью надо...
