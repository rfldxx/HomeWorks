
## "Сумма двух"

### Условие

Дан массив целых чисел `nums` и целочисленное значение переменной `target`, верните **индексы** двух чисел таким образом, чтобы они в сумме давали `target`.

### Решение
Хотелось бы делать по типу: 
```py
new_a = [f(x) for x in a].sort()
```

Однако, `.sort()` возвращает `None`. \
К счастью, по всей моде, для получение самого списка есть отдельная функция с другим названием: `sorted()`.  \
При это можно и отпустить квадратные скобки, вместо: `sorted( [f(x) for x in a] )`, можно написать сразу:
```py
cmb = sorted( (x, indx) for (indx, x) in enumerate(a) )
```

Ну и ещё из прикольного, можно "разбирать" вложенные типы (например в C++ пока что нельзя так делать: `auto [a, [c,d]]`).
```py
for i, (x, indx) in enumerate(cmb):
```



## "Угадай число"

### Задание
Реализуйте классическую игру "угадай число" перебором и бинарным поиском. 



### Решение
Нам не хочется писать два цикла: один в переборе, другой в бинарном поиске. Давай-те рассмотрим диапозон: $(l, r)$.

У нас **запросы вида**: "Загаданное число $> x$?"


В последовательном поиске: задаем запрос с $x = l$. Если ответ нет, то поскольку прошлые значения уже были рассмотренны, то $l$ - загаданное число, иначе говоря переходим к диапозону $(l, l)$. Если ответ да, то переходим к диапозону $(l+1, r)$.

В бинарном поиске: задаем запрос с $x = \frac{1}{2} l + \frac{1}{2} r$. Если ответ нет, то переходим к диапозону $(l, x)$. Если ответ да, то переходим к диапозону $(x+1, r)$.

Мы видим, что два метода отличаются только способом определения числа $x$!
```py
def solver_gate(l, r, x, ask):
    return ( (l, x), (x+1, r) )[ ask(x) ]

def seq_x(l, r): return l
def bin_x(l, r): return (l+r)//2

def guess_number(target, lst, def_x):
    kernel = lambda l, r: solver_gate(l, r, def_x(l, r), lambda i: target > lst[i])

    cnt = 0
    l, r = 0, len(lst)-1
    while( l != r ):
        l, r = kernel(l, r)
        cnt += 1
    
    return lst[l], cnt
```


## "Построение бинарного дерева"

### Задание
...

### Решение
Вообще забавно:
```py
def buid_tree(h, r, f, g):
    return { r : [buid_tree(h-1, f(r), f, g),
                  buid_tree(h-1, g(r), f, g)] if h else [] }

# h = 3 : 
# {1: [{2: [{3: [{4: []}, {6: []}]}, {4: [{5: []}, {8: []}]}]}, {2: [{3: [{4: []}, {6: []}]}, {4: [{5: []}, {8: []}]}]}]}
```
