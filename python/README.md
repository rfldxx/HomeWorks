
## "Сумма двух"

### Условие

Дан массив целых чисел `nums` и целочисленное значение переменной `target`, верните **индексы** двух чисел таким образом, чтобы они в сумме давали `target`.

### Решение
Хотелось бы делать по типу: 
```py
new_a = [f(x) for x in a].sort()
```

Однако, `.sort()` возвращает `None`. \
К счастью, по всей моде, для получение самого списка есть отдельная функция с другим названием: `sorted()`.  \
При это можно и отпустить квадратные скобки, вместо: `sorted( [f(x) for x in a] )`, можно написать сразу:
```py
cmb = sorted( (x, indx) for (indx, x) in enumerate(a) )
```

Ну и ещё из прикольного, можно "разбирать" вложенные типы (например в C++ пока что нельзя так делать: `auto [a, [b, c]]`).
```py
for i, (x, indx) in enumerate(cmb):
```



## "Угадай число"

### Задание
Реализуйте классическую игру "угадай число" перебором и бинарным поиском. 



### Решение

У нас **запросы вида**: "Загаданное число $> x$?"

Нам не хочется писать два цикла: один в переборе, другой в бинарном поиске. Давай-те рассмотрим диапазон: $(l, r)$.

В последовательном поиске задаем запрос с $x = l$. **Если ответ нет**, то поскольку прошлые значения уже были рассмотренны, то $l$ - загаданное число, иначе говоря переходим к диапазону $(l, l)$. **Если ответ да**, то переходим к диапазону $(l+1, r)$.

В бинарном поиске задаем запрос с $x = \frac{1}{2} l + \frac{1}{2} r$. **Если ответ нет**, то переходим к диапазону $(l, x)$. **Если ответ да**, то переходим к диапазону $(x+1, r)$.

Мы видим, что два метода отличаются только способом определения числа $x$!
```py
def solver_gate(l, r, x, ask):
    return ( (l, x), (x+1, r) )[ ask(x) ]

def seq_x(l, r): return l
def bin_x(l, r): return (l+r)//2

def guess_number(target, lst, def_x):
    kernel = lambda l, r: solver_gate(l, r, def_x(l, r), lambda i: target > lst[i])

    cnt = 0
    l, r = 0, len(lst)-1
    while( l != r ):
        l, r = kernel(l, r)
        cnt += 1
    
    return lst[l], cnt
```

Оба метода требуют чтобы диапазон был отсортированным. Поэтому, так как в условии не гарантируется что `lst` отсортирован, в любом случае будем сортировать его.

В тестировании для "декартового произведения" использовал:
```py
for a, b in itertools.product(A, B):
```

Аннотация типов для "функции" `bool f(int)`:
```py
Callable[[int], bool]
```



## "Построение бинарного дерева"

### Задание
...

### Решение
Вообще забавно:
```py
def buid_tree(h, r, f, g):
    return { r : [buid_tree(h-1, f(r), f, g),
                  buid_tree(h-1, g(r), f, g)] if h else [] }

# h = 3 : 
# {1: [{2: [{3: [{4: []}, {6: []}]}, {4: [{5: []}, {8: []}]}]}, {2: [{3: [{4: []}, {6: []}]}, {4: [{5: []}, {8: []}]}]}]}
```
