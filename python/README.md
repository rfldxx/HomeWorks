
## Lab1. "Сумма двух"

### Условие

Дан массив целых чисел `nums` и целочисленное значение переменной `target`, верните **индексы** двух чисел таким образом, чтобы они в сумме давали `target`.

### Решение
Хотелось бы делать по типу: 
```py
new_a = [f(x) for x in a].sort()
```

Однако, `.sort()` возвращает `None`. \
К счастью, по всей моде, для получение самого списка есть отдельная функция с другим названием: `sorted()`.  \
При это можно и отпустить квадратные скобки, вместо: `sorted( [f(x) for x in a] )`, можно написать сразу:
```py
cmb = sorted( (x, indx) for (indx, x) in enumerate(a) )
```

Ну и ещё из прикольного, можно "разбирать" вложенные типы (например в C++ пока что нельзя так делать: `auto [a, [b, c]]`).
```py
for i, (x, indx) in enumerate(cmb):
```



## Lab2. "Угадай число"

### Задание
Реализуйте классическую игру "угадай число" перебором и бинарным поиском. 



### Решение

У нас **запросы вида**: "Загаданное число $> x$?"

Нам не хочется писать два цикла: один в переборе, другой в бинарном поиске. Давай-те рассмотрим диапазон: $(l, r)$.

В бинарном поиске задаем запрос с $x = \frac{1}{2} l + \frac{1}{2} r$. **Если ответ нет**, то переходим к диапазону $(l, x)$. **Если ответ да**, то переходим к диапазону $(x+1, r)$.

В последовательном поиске задаем запрос с $x = l$. **Если ответ нет**, то поскольку прошлые значения уже были рассмотренны, то $l$ - загаданное число, иначе говоря переходим к диапазону $(l, l)$. **Если ответ да**, то переходим к диапазону $(l+1, r)$.

Мы видим, что два метода отличаются только способом определения числа $x$!
```py
def solver_gate(l, r, x, ask):
    return ( (l, x), (x+1, r) )[ ask(x) ]

def seq_x(l, r): return l
def bin_x(l, r): return (l+r)//2

def guess_number(target, lst, def_x):
    kernel = lambda l, r: solver_gate(l, r, def_x(l, r), lambda i: target > lst[i])

    cnt = 0
    l, r = 0, len(lst)-1
    while( l != r ):
        l, r = kernel(l, r)
        cnt += 1
    
    return lst[l], cnt
```

Оба метода требуют чтобы диапазон был отсортированным. Поэтому, так как в условии не гарантируется что `lst` отсортирован, в любом случае будем сортировать его.

В тестировании для "декартового произведения" использовал:
```py
for a, b in itertools.product(A, B):
```

Аннотация типов для "функции" `bool f(int)`:
```py
Callable[[int], bool]
```



## Lab3&5. "Построение бинарного дерева"

### Задание
...

### Решение
Вообще забавно:
```py
def gen_bin_tree(h, r, f, g):
    return { r : [gen_bin_tree(h-1, F(r), f, g) for F in [f, g]] if h > 0 else [] }

# gen_bin_tree(2, 1, lambda x: x+1, lambda y: y*3) :
# {1: 
#     [{2: 
#         [{3: []}, 
#          {6: []}]}, 
#      {3: 
#         [{4: []}, 
#          {9: []}]}]}
```

Так как узел дерева представляет собой `Dict` (неупорядоченноe множество), то как нам обращаться к его единственному элементу? Можно так:
```py
(root_value, subTrees), = Tree.items()
```
Запятая после `(key, value)` говорит: "распаковать первый элемент последовательности" (спасибо бесплатный deepseek).

новые типы: Any


### Тесты
Так как сама задача получилось достаточно маленькая, то было решено упороться в генерацию тестирования:

Тесты по сути проверяют как дерево выданное функцией `gen_bin_tree` согласуется с обходами в глубину и ширину. \
Предположение: если мы получаем в этих обходах ожидаемые значения - то мы можем называть эту структуру деревом.

Более подробно про функции расписано в документации к коду (там она вроде очень хорошая получилась).

Также в этот раз тестирование реально помогало найти ошибки (правда ошибки были в реализации самих тестов...). Удобным оказалось, что в `self.assert`-ы можно передавать дополнительный аргумент - сообщение в случае ошибки. И при реккурсивном вызове `assert`-а, можно таскать с собой путь:
```py
def recurseve_check(..., path = ""):
    ...
    self.assertEqual(root_value, expected_value, "Error in position:" + path)
        
    for i in range(len(subTrees)):
        recurseve_check(..., path + " " + ("LR"[i]))
```

### Заметки

- Функция с состоянием
    ```py
    def newCounter():
        cnt = 0
        def f():
            nonlocal cnt
            cnt += 1  # ужас, в питоне нельзя делать return ++cnt
            return cnt
        return f
    ```

- Создание функций в цикле:
    ```py
    def GenF(i):
        def new_f(x): return (i+1)*x
        return new_f
    
    functions = [GenF(i) for i in range(3)]
    ```

    <details>
    
    <summary> осторожно ловушка! </summary>

    Изначально тут было написано:
    ```py
    functions = []

    for i in range(3):
        def new_f(x): return (i+1)*x
        functions.append(new_f)
    ```

    И это верно работало при вызове в цикле:
    ```py
    for i in range(3):
        print( functions[i](5) )
    #  5
    # 10
    # 15
    ```
    Однако если захочется повызывать по элементно, то:
    ```py
    print( functions[0](5) )  #  15
    print( functions[1](5) )  #  15
    print( functions[2](5) )  #  15
    ```
    Оказывается все эти функции будут смотреть именно на переменную $i$ в "общем пространстве"! 

    </details>

- Другой способ создания фунций в цикле (т.к. Аргументы по умолчанию вычисляются в момент определения функции): 
    ```py
    functions = []
    for i in range(3):
        def F(x, i = i): return (i+1)*x
        functions.append(F)
    ```



## Lab4. Battle Royale Факториалов

Чтобы можно было работать с большими факториалами нам потребуется изменения:
```py
import sys

# изменение глубины рекурсии
sys.setrecursionlimit(100000)

# изменение max размера длинной арифметики
sys.set_int_max_str_digits(100000)
```

В классической реализации факторила (что через рекурсию, что через цикл) мы постепенно накапливаем ответ, умножая на каждом шаге на "маленькие" числа (из промежутка $[1, n]$).

Однако, я вроде слышал, что лучше перемножать числа примерно одного порядка. \
Поэтому далее рассмотрим ещё варианты как можно подсчитать факториал, в конце значения и скорость будут сравниваться с библиотечной функцией: `math.factorial(n)`.



### Свёртка промежутка

При рефакторинге, было замечено, что по сути везде используются только три варианта перемножения промежутка чисел:
![alt](lab4/merging.png)

- `first_pair_merging` - Последовательное умножение первого аргумента на остальные (как в классическом подсчете факториала).
- `adjacent_pair_merging` - Поэтапное перемножение соседей: 1-го и 2-го, 3-го и 4-го, и т.д. В итоге на каждом этапе значений стновится в два раза меньше (для эффективности реализации всё происходит в одном списке).
- `min_pair_merging` - Объединие двух минимальных значений на каждом этапе. Для эффективного поиска и извлечения минимума, а также вставки нового элемента, использаволась структура `heapq`.
    ```py
    import heapq
    data = [...]
    heapq.heapify(data)
    min1 = heapq.heappop(data)
    min2 = heapq.heappop(data)
    heapq.heappush(data, min1*min2)
    ```

Поэтому во всех функциях появился дополнительный аргумент: `merging` - функция сворачивающая промежуток чисел в одно число. \
В данный момент у каждой функции рассмотриваеся только один вариант `merging`-а, по хорошему, можно для каждого способа подсчета факториала перебрать все три способа сворачивания и выбать лучший.


### Различные варианты подсчета факториала: 

* `factorial` - библиотечная функция

*  `fact_recursive` - вычисление через рекурсию

* `fact_classic` - вычисление через привычный цикл (вызов `first_pair_merging` на числах $[1, n]$)

* `fact_classic_1` - предварительный `shuffle` промежутка $[1, n]$ (в надежде что в произведениях будут числа примерно одного порядка) и затем вызов `adjacent_pair_merging`

* `fact5` - вызов `min_pair_merging` на числах $[1, n]$

* `fact3` - изначально, я почему то решил что использование приоритетной очереди на $n \sim 10^4$ достаточно затратно (хотя теперь кажется что на таких малых списках это буквально 10ms и смысла в этой оптимизации нет), поэтому это способ доставать числа "примерно" одного порядка за $O(1)$ амортизированно. \
Будем использовать две отсортированные очереди $A=[]$ и $B=[1,2, ..., n]$ - условно говоря в $A$ храняться значения порядка $x$, а в $B$ - значения порядка $x^2$ и более. \
Если в $A$ меньше чем $2$ элемена, то перетаскиваем их из $B$. \
Далее, пока $B[0] < A[0] \cdot A[1]$ мы будем перетаскивать $B[0]$ в конец $A$. \
Затем удаляем $A[0]$ и $A[1]$, и записываем элемент $A[0] \cdot A[1]$ в начало $B$.

* `fact3_1` - сравнение не самих (возможно очень длинных) чисел $B[0]$ и $A[0] \cdot  A[1]$, а просто количества знаков в них: `B[0].bit_length()`. \
Но это не дало почти никакого приимущества - действительно, наверное у больших чисел навряд ли совпадет количество "цифр" и питон при сравнени наверное смотрит сначала на разрядность и только потом начинает посимвольное сравнивнение

* `fact6` - Расcмотрим разложение на простые множители: $n! = p_1^{k_1} \dots p_l^{k_l}$. \
Для каждого простого числа мы можем опредилить с какой кратностью оно входит в факториал. \
Далее возведём в степень с помошью быстрого возведения в степень и перемножим полученые $[p_1^{k_1}, p_2^{k_2}, \dots, p_l^{k_l}]$ (здесь использовалось перемножение через `min_pair_merging`).
 
* `fact6_1` - похоже на `fact6`, только давайте не каждое простое число возводить в степень по отдельности, а найдём все простые числа которые входят одниковае число раз, например: $p_1^l, p_2^l, p_3^l$, премножим их: $p_1 \cdot p_2 \cdot p_3$ и результат их произведения будем возводить в степень $l$. \
Тут уже больше списков для сворачвания: список $[p1, p2, p3]$ пермножался через `adjacent_pair_merging`, а полученные степени: $[(p_1 p_2 p_3)^l, ...]$ через `min_pair_merging`.


![alt](lab4/large_N.png)



## Lab6. Сравнение реккурсивной и не реккурсивной реализации "Построение бинарного дерева"

### Рекурсивная реализация
Подробнее это разбиралось в [lab3](lab3/).
```py
def build_tree_recursive(h, r, f, g):
    return { r : [build_tree_recursive(h-1, F(r), f, g) for F in [f, g]] if h > 0 else [] }
```

### Дерево в виде массива
В нерекурсивном построении, будем хранить дерево как просто 0-индексированный массив `TreeList` на $2^{h+1} - 1$ элемент. \
Корень имеет значение равное `TreeList[0]`. \
Для вершины со значением по индексу $i$, левый потомок имеет значение в индексе $2 i +1$, правый - в индексе $2 i+2$.

Зная функция `f` и `g` (которые по значению в текущем узле возвращают  значение для левого / правого потомка) мы можем просто проитерировать по всем $i$:
```py
TreeList[0] = root_value
for i in range(2**h - 1):
    TreeList[2*i+1] = f(TreeList[i])
    TreeList[2*i+2] = g(TreeList[i])
```

Итого мы получим какое-то из представлений дерева.

### Дерево в формате как и у build_tree_recursive
Для этого будем строить дерево "снизу". \
У нас уже есть `TreeList`, индексы из промежутка $[2^l-1, 2^{l+1}-1)$ - соответствуют слою дерева на глубине $l$.

Будем строить итоговое дерево по слоям `TreeLayer`. \
Самый нижний слой это листья: `TreeLayer = [ {x : []} for x in TreeList[2**h-1:] ]`. \
Дальше мы строим следующий слой по предыдущему как: `{TreeList[i] : [TreeLayer[j], TreeLayer[k]] }`, где индексы $i$, $j$, $k$ аккуратно выражаются.

Итого:
```py
def build_tree_iterative(h, r, f, g):
    TreeList = build_tree_list(h, r, f, g)

    N = 2**(h+1) - 1  # число вершин в дереве
    L = 2**h    # количество листьев в дереве

    shift = N - L
    TreeLayer = [ {x : []} for x in TreeList[shift:] ]

    while L > 1:
        L //= 2
        shift -= L
        newTreeLayer = [None] * L
        for i in range(L):
            newTreeLayer[i] =  { TreeList[shift + i] : [ TreeLayer[2*i], TreeLayer[2*i + 1] ] } 

        TreeLayer = newTreeLayer
        
    return TreeLayer[0]
```

Как же хорошо, что:
```py
print( build_tree_recursive(...) == build_tree_iterative(...) ) #True
```




### Результаты:
![alt](lab6/graph.png)

