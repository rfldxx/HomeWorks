
## Lab1. "Сумма двух"

### Условие

Дан массив целых чисел `nums` и целочисленное значение переменной `target`, верните **индексы** двух чисел таким образом, чтобы они в сумме давали `target`.

### Решение
Хотелось бы делать по типу: 
```py
new_a = [f(x) for x in a].sort()
```

Однако, `.sort()` возвращает `None`. \
К счастью, по всей моде, для получение самого списка есть отдельная функция с другим названием: `sorted()`.  \
При это можно и отпустить квадратные скобки, вместо: `sorted( [f(x) for x in a] )`, можно написать сразу:
```py
cmb = sorted( (x, indx) for (indx, x) in enumerate(a) )
```

Ну и ещё из прикольного, можно "разбирать" вложенные типы (например в C++ пока что нельзя так делать: `auto [a, [b, c]]`).
```py
for i, (x, indx) in enumerate(cmb):
```



## Lab2. "Угадай число"

### Задание
Реализуйте классическую игру "угадай число" перебором и бинарным поиском. 



### Решение

У нас **запросы вида**: "Загаданное число $> x$?"

Нам не хочется писать два цикла: один в переборе, другой в бинарном поиске. Давай-те рассмотрим диапазон: $(l, r)$.

В бинарном поиске задаем запрос с $x = \frac{1}{2} l + \frac{1}{2} r$. **Если ответ нет**, то переходим к диапазону $(l, x)$. **Если ответ да**, то переходим к диапазону $(x+1, r)$.

В последовательном поиске задаем запрос с $x = l$. **Если ответ нет**, то поскольку прошлые значения уже были рассмотренны, то $l$ - загаданное число, иначе говоря переходим к диапазону $(l, l)$. **Если ответ да**, то переходим к диапазону $(l+1, r)$.

Мы видим, что два метода отличаются только способом определения числа $x$!
```py
def solver_gate(l, r, x, ask):
    return ( (l, x), (x+1, r) )[ ask(x) ]

def seq_x(l, r): return l
def bin_x(l, r): return (l+r)//2

def guess_number(target, lst, def_x):
    kernel = lambda l, r: solver_gate(l, r, def_x(l, r), lambda i: target > lst[i])

    cnt = 0
    l, r = 0, len(lst)-1
    while( l != r ):
        l, r = kernel(l, r)
        cnt += 1
    
    return lst[l], cnt
```

Оба метода требуют чтобы диапазон был отсортированным. Поэтому, так как в условии не гарантируется что `lst` отсортирован, в любом случае будем сортировать его.

В тестировании для "декартового произведения" использовал:
```py
for a, b in itertools.product(A, B):
```

Аннотация типов для "функции" `bool f(int)`:
```py
Callable[[int], bool]
```



## Lab3. "Построение бинарного дерева"

### Задание
...

### Решение
Вообще забавно:
```py
def gen_bin_tree(h, r, f, g):
    return { r : [gen_bin_tree(h-1, F(r), f, g) for F in [f, g]] if h > 0 else [] }

# gen_bin_tree(2, 1, lambda x: x+1, lambda y: y*3) :
# {1: 
#     [{2: 
#         [{3: []}, 
#          {6: []}]}, 
#      {3: 
#         [{4: []}, 
#          {9: []}]}]}
```

Так как узел дерева представляет собой `Dict` (неупорядоченноe множество), то как нам обращаться к его единственному элементу? Можно так:
```py
(root_value, subTrees), = Tree.items()
```
Запятая после `(key, value)` говорит: "распаковать первый элемент последовательности" (спасибо бесплатный deepseek).

новые типы: Any



Так как сама задача получилось достаточно маленькая, то было решено упороться в генерацию тестирования:

- Функция с состоянием
    ```py
    def newCounter():
        cnt = 0
        def f():
            nonlocal cnt
            cnt += 1  # ужас, в питоне нельзя делать return ++cnt
            return cnt
        return f
    ```

- Создание функций в цикле:
    ```py
    def GenF(i):
        def new_f(x): return (i+1)*x
        return new_f
    
    functions = [GenF(i) for i in range(3)]
    ```

    <details>
    
    <summary> осторожно ловушка! </summary>

    Изначально тут было написано:
    ```py
    functions = []

    for i in range(3):
        def new_f(x): return (i+1)*x
        functions.append(new_f)
    ```

    И это верно работало при вызове в цикле:
    ```py
    for i in range(3):
        print( functions[i](5) )
    #  5
    # 10
    # 15
    ```
    Однако если захочется повызывать по элементно, то:
    ```py
    print( functions[0](5) )  #  15
    print( functions[1](5) )  #  15
    print( functions[2](5) )  #  15
    ```
    Оказывается все эти функции будут смотреть именно на переменную $i$ в "общем пространстве"! 

    </details>


- Также в этот раз тестирование реально помогало найти ошибки (правда ошибки были в реализации самих тестов...). Удобным оказалось, что в `self.assert`-ы можно передавать дополнительный аргумент - сообщение в случае ошибки. И при реккурсивном вызове `assert`-а, можно таскать с собой путь:
    ```py
    def recurseve_check(..., path = ""):
        ...
        self.assertEqual(root_value, expected_value, "Error in position:" + path)
            
        for i in range(len(subTrees)):
            recurseve_check(..., path + " " + ("LR"[i]))
    ```
