### Решение
Реккурсивное построение дерева:
```py
def gen_bin_tree(h, r, f, g):
    return { r : [gen_bin_tree(h-1, F(r), f, g) for F in [f, g]] if h > 0 else [] }

# gen_bin_tree(2, 1, lambda x: x+1, lambda y: y*3) :
# {1: 
#     [{2: 
#         [{3: []}, 
#          {6: []}]}, 
#      {3: 
#         [{4: []}, 
#          {9: []}]}]}
```

Так как узел дерева представляет собой `Dict` (неупорядоченноe множество), то как нам обращаться к его единственному элементу? Можно так:
```py
(root_value, subTrees), = Tree.items()
```
Запятая после `(key, value)` говорит: "распаковать первый элемент последовательности".

новые типы: Any



### Тесты

Тесты по сути проверяют как дерево выданное функцией `gen_bin_tree` согласуется с обходами в глубину и ширину. \
Предположение: если мы получаем в этих обходах ожидаемые значения - то мы можем называть эту структуру деревом.

Более подробно про функции расписано в документации к коду (там она вроде очень хорошая получилась).

Также в этот раз тестирование реально помогало найти ошибки (правда ошибки были в реализации самих тестов...). Удобным оказалось, что в `self.assert`-ы можно передавать дополнительный аргумент - сообщение в случае ошибки. И при реккурсивном вызове `assert`-а, можно таскать с собой путь:
```py
def recurseve_check(..., path = ""):
    ...
    self.assertEqual(root_value, expected_value, "Error in position:" + path)
        
    for i in range(len(subTrees)):
        recurseve_check(..., path + " " + ("LR"[i]))
```

### Заметки

- Функция с состоянием:
    ```py
    def newCounter():
        cnt = 0
        def f():
            nonlocal cnt
            cnt += 1  # ужас, в питоне нельзя делать return ++cnt
            return cnt
        return f
    ```

- Создание функций в цикле:
    ```py
    def GenF(i):
        def new_f(x): return (i+1)*x
        return new_f
    
    functions = [GenF(i) for i in range(3)]
    ```

    <details>
    
    <summary> осторожно ловушка! </summary>

    Изначально тут было написано:
    ```py
    functions = []

    for i in range(3):
        def new_f(x): return (i+1)*x
        functions.append(new_f)
    ```

    И это верно работало при вызове в цикле:
    ```py
    for i in range(3):
        print( functions[i](5) )
    #  5
    # 10
    # 15
    ```
    Однако если захочется повызывать по элементно, то:
    ```py
    print( functions[0](5) )  #  15
    print( functions[1](5) )  #  15
    print( functions[2](5) )  #  15
    ```
    Оказывается все эти функции будут смотреть именно на переменную $i$ в "общем пространстве"! 

    </details>


- Аргументы по умолчанию вычисляются в момент определения функции - так что можно ещё так делать: 
    ```py
    functions = []
    for i in range(3):
        def F(x, i = i): return (i+1)*x
        functions.append(F)
    ```
