## Недоступный сайт
Сделать недоступный для скрин-ридера сайт.

### Описание сайта
Я сделал текстовый "сайт" с сслыками, который полностью отрисовывает своё содержимое в элементе HTML5 Canvas. (Не используется никаких дополнительных библиотек, т.е. можно просто запустить в браузере.)

Сайт собирается из текстового описания. В тексте можно создавать ссылки на другие страницы этого сайта (подобно markdown) и преходить по ним с помощью нажатия мышкой. Доступные ссылки окрашены в синий, не доступные - в красный. При наведении курсора на ссылку тип курсора становится `"pointer"`.

Также на страницах доступен вертикальный скрол, с помощью: колесика мыши и стрелок вверх/вниз.

Ссылка на cайт: [unreadable_cite.html](unreadable_cite.html)

### Детали реализации
Каждая страница представляет из себя объект: `{page_id, content}`:
* `page_id` - не отрицательное целое число.
* `content` - строка, которая содержит текст всей страницы.

При этом в строке `content` могут быть ссылки. Формат ссылки: `[[текст ссылки](page_id)]`. На странице будет отображен только текст ссылки. Ссылки парсятся в ручную, ищутся первые появления "ключевых" частей: `[[`, `](` и `)]`.


Сайт "генерируется" из объекта `cite` который должен иметь следующий вид (см. самое начало js кода):
```js
let cite = {
    pages: [
        { page_id: unsigned_int, content: string },
        { page_id: unsigned_int, content: string },
        ...
    ]
};
```

Текст печатается на canvas по буквенно. Для каждого символа выделен прямоугольник фиксированного размера. Cимвол размещается в центре свего прямоугольника с помощью встроенной в canvas функции: `fillText(str, x, y)`. \
На сайте есть возможность включить флажок: "Показывать рамки ограничивающие символы".

Чтобы был доступен скролл, изначально вся страница генерируется на объекте: `OffscreenCanvas`. Затем на отображаемый canvas переносится определенная часть от полной страницы, с помощью встроенной в canvas функции: `drawImage(src, ...)`.

Ну и про клики мышкой... В общем, каждый символ ссылки сохраняется отдельно, и при движении мышкой идет перебор всех таких позиций. По хорошему бы последовательные прямоугольники объединять в один прямоугольник, или делать не линейный перебор всех символов, а отсортировав по осям $x$ и $y$.


### Пример
```js
let cite = {
    pages: [
        {
            page_id: 0,
            content: "Привет! Это сайт на canvas. Вы можете посетить:\n" +
                     " * [[страницу 1](1)]<<<\n" +
                     " * [[сслыку на битую страницу (будет нарисованна красной)](153)]\n" +
                     " * [[а это даже не ссылка](0)\n" +  // нет закрывающей квадратной скобки в конце
                     " * [[тоже не ссылка :] ](0)]\n"  +  // из-за того что ищется первая ']' и не проверяются следующие варианты
                     " * [[страницу 2](10)] (нет фантазии)"
                     
        },
        {
            page_id: 10,
            content: "[[НА ГЛАВНУЮ](0)]\n" +
                     "Это страница 2. Как видите, порядок объявления не важен."
        },
        {
            page_id: 1,
            content: "[[НА ГЛАВНУЮ](0)]\n" +
                     "Это страница 1.\n Как насчёт перейти на [[страницу X](777)]?" 
        },
        {
            page_id: 777,
            content: "[[НА ГЛАВНУЮ](0)]\n" +
                     "Я чет нигде не указал, но изначально отрисовывается страница, которая идет самой первой в массиве `pages[]`!"
        }
    ]
};
```
