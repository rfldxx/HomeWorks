## Недоступный сайт
Сделать недоступный для скрин-ридера сайт.

### Описание сайта
Я сделал текстовый "сайт" с сслыками, который полностью отрисовывает своё содержимое в элементе HTML5 Canvas. (Не используется никаких дополнительных библиотек, т.е. можно просто запустить в браузере.)

Сайт собирается из текстового описания. В тексте можно создавать ссылки на другие страницы этого сайта (подобно markdown) и преходить по ним с помощью нажатия мышкой. Доступные ссылки окрашены в синий, не доступные - в красный. При наведении курсора на ссылку тип курсора становится `"pointer"`.

Также на страницах доступен вертикальный скрол, с помощью: колесика мыши и стрелок вверх/вниз.

Ссылка на cайт: [unreadable_cite.html](unreadable_cite.html)

### Детали реализации
Каждая страница представляет из себя объект: `{page_id, content}`:
* `page_id` - не отрицательное целое число.
* `content` - строка, которая содержит текст всей страницы.

При этом в строке `content` могут быть ссылки. Формат ссылки: `[[текст ссылки](page_id)]`. На странице будет отображен только текст ссылки. Ссылка парсится в ручную, ищутся первые появления "ключевых" частей: `[[`, `](` и `)]`.


Сайт "генерируется" из объекта `cite` который должен иметь следующий вид (см. самое начало js кода):
```js
let cite = {
    pages: [
        { page_id: unsigned_int, content: string },
        { page_id: unsigned_int, content: string },
        ...
    ]
};
```

Текст печатается на canvas по буквенно. Для каждого символа выделен прямоугольник фиксированного размера. Cимвол размещается в центре свего прямоугольника с помощью встроенной в canvas функции: `fillText(str, x, y)`. \
На сайте есть возможность включить флажок: "Показывать рамки ограничивающие символы".

Чтобы был доступен скролл, изначально вся страница генерируется на объекте: `OffscreenCanvas`. Затем на отображаемый canvas переносится определенная часть от полной страницы, с помощью встроенной в canvas функции: `drawImage(src, ...)`.

Ну и про клики мышкой... В общем, каждый символ ссылки сохраняется отдельно, и при движении мышкой идет перебор всех таких позиций. По хорошему бы последовательные прямоугольники объединять в один прямоугольник, или делать не линейный перебор всех символов, а отсортировав по осям $x$ и $y$.
